Setstate is asynchronous, but it does not return a promise. so while 
the value is still being set, the console already logs out the incorrect (previous value)
Quick way to fi this. set a watch on the func, so when any thing changes to the func, then useeffect will run again



const Hello = () => {
  const [v, setV] = React.useState(1);

   React.useEffect(() => {
    setTimeout(() => {
      setV(2);
    }, 3000)
  }, [doSomethingWithData(v)]);


  return (
    <div>
      <h1>Hello, world {v}!</h1>
    </div>
  );
}

const doSomethingWithData = (v) => {
  console.log('Variable value is: ' + v);
}

ReactDOM.render(
  <Hello />,
  document.getElementById('root')
);
